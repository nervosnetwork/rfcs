# CFB Encoding

CFB (Canonical FlatBuffers) is a restricted variant of FlatBuffers for producing unequivocal transfer syntax.

As described in [FlatBuffers Internals][flatbuffers-internals]:

[flatbuffers-internals]: https://google.github.io/flatbuffers/flatbuffers_internals.html

> On purpose, the format of FlatBuffers leaves a lot of details about where exactly things live in memory undefined, e.g. fields in a table can have any order, and objects to some extent can be stored in many orders. This is because the format doesn't need this information to be efficient, and it leaves room for optimization and extension (for example, fields can be packed in a way that is most compact). Instead, the format is defined in terms of offsets and adjacency only. This may mean two different implementations may produce different binaries given the same input values, and this is perfectly valid.

CFB eliminates all the undefined encodings. For a given data structure, the encoded binary is determined.

CFB is useful in cryptography to generate a determined hash from a complex data structure:

1.  Encode the data structure into binary using CFB.
2.  Hash the binary as the identifier.

The identifier generated by original FlatBuffers is malleable since it is easy to encode the data into a different binary without modifying the data itself.

The name comes from [CER], which is a restricted variant of BER to encode data structures described by ASN.1.

[cer]: https://en.wikipedia.org/wiki/X.690#CER_encoding

## Format components

The buffer consists of a root table offset and the data portion.

The root table offset is the start position of the root table in the buffer.
The data portion is a series of components, including tables, unions, strings, and vectors.

All components must align by padding minimal amount of zeros before to meet
the alignment requirements.

### Data order

All the components in the data portion construct a tree, in which the root table is the root node. Only the tables and vectors have children nodes:

- The table's children are all the reference fields, including tables, unions, strings, and vectors.
- The vector's children, straightforwardly, are the items in it when it is a vector of tables, unions or strings.

The tree lays down into an array using depth-first traverse.

```text
                     +---+
                     | 1 |
                     +-+-+
                       |
                +-------------+
                |      |      |
              +-+-+  +-+-+  +-+-+
              | 2 |  | 7 |  | 8 |
              +-+-+  +---+  +-+-+
                |             |
         +------+             +------+
         |      |             |      |
       +-+-+  +-+-+         +-+-+  +-+--+
       | 3 |  | 6 |         | 9 |  | 12 |
       +-+-+  +---+         +-+-+  +----+
         |                    |
  +------+                    +-------+
  |      |                    |       |
+-+-+  +-+-+                +-+--+  +-+--+
| 4 |  | 5 |                | 10 |  | 11 |
+---+  +---+                +----+  +----+
```

The order of the children of a table is the same as in the schema. The vector children have the same sequence in the vector.

The data portion must only contain the components in the tree.

See the example [data-order].

[data-order]: examples/data-order.md

### Vtable order and deduplication

The table can only refer to vtable before it. If the vtable already
exists in the buffer before the table, the table must refer to the existing
vtable. Otherwise, the vtable must be created and append to the buffer immediately before the table itself.

In the example [data-order], vtables of `monster` and `stat` are just
before the tables. However, `loots[1]` and `loots[2]` reuses the
vtable of `stat` because of deduplication.

### Data alignment

The table's starting position `t` must be aligned, such that `t` is multiple of 4, and `t + 4` is the multiple of the most significant alignment of the present field in the table. All the fields in the table must be aligned as well.

The vtable's starting position `t` must be a multiple of 2.

The string's starting position `t` must be a multiple of 4.

The vector's starting position `t` must be a multiple of 4, and `t + 4` is the multiple of the item alignment. **Specially**, if a vector of `ubyte` is marked as a nested buffer, `t + 4` must be multiple of 8.

Zeros are padded before to ensure the alignment. The number of zeros must be minimal. There should not be any padding at the end of the buffer.

See the example [data-alignment].

[data-alignment]: examples/data-alignment.md

### Table fields order

Following criterion explains how to sort the table embed fields and references.

- First sort fields by the alignment in descending order.
- Then sort fields with the same alignment by the size in descending order.
- For fields have the same alignment and size, follow the sequence in the schema.

The union field is split into two separate virtual fields, replacing its original location in the schema.

- Split single union field into 1-byte type field and 4-bytes reference field.
- Split union vector field into type vector and reference vector.

See the example [table-fields-order].

[table-fields-order]: examples/table-fields-order.md

### Default values

The scalar field in a table which equals the default value must omit in the buffer.

If a union is NONE, both the union type and value must omit.

Except for the root table, it is not allowed to refer to a table with all fields omitted. References to empty strings and vectors are also forbidden. Instead, these fields should not be in the table.

## A Builder Strategy

Since there is only one correct way to build the buffer for the give data, the builder interface has less freedom than the standard FlatBuffers. However, it is also an advantage, since CFB builder is simple.

CFB can take advantage of the simplicity to construct buffers forwards while flatc and flatcc choose to build backwards.

For example, to encode a table, CFB first asks for its vtable. It appends the
vtable to the buffer if it does not exist yet. From the vtable, it is easy to
build the table itself, leaving all reference some dummy values, such as zero.
The CFB handles each reference field according to the table fields order
specification, and fills the offsets in the table.

Similarly, knowing the length of the array first, CFB can allocate the array, then constructs each item consecutively.
